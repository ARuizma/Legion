runApp()
runApp()
data[input$zcol]
dat[input$zcol]
df2()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
help(btnInput)
help(buttonInput)
??buttonInput
??`shiny1
help(shiny)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
y1
runApp()
runApp()
help(abe)
??abe
runApp()
runApp()
runApp()
runApp()
p
gg_color_hue <- function(n) {
hues = seq(15, 375, length=n+1)
hcl(h=hues, l=65, c=100)[1:n]
}
plotMixMdlComps <- function(x, mu, sigma, lam) {
lam * dnorm(x, mu, sigma )
}
clusterDf <- data.frame(cluster = c(6,5,4,8,0,7,3),
mu = c(0.73908779, 0.43233777, 0.28041006, 0.35627709,
0.09330585, 0.18250758, 0.56998734),
sigma = c(0.06472281, 0.03218096, 0.02779751,
0.02208605, 0.02716692, 0.01890661,
0.02995616),
lambda = c(0.042749908, 0.254485536, 0.205602343,
0.404705236, 0.061058220, 0.024166972,
0.007231783))
cols <- nrow(clusterDf) %>%
gg_color_hue()
inDf <- data.frame(x = c(0,1))
p <- ggplot(inDf, aes(x)) +
xlim(0,1) +
ylim(0,10)
for (i in 1:nrow(clusterDf)) {
p <- p + stat_function(geom = "line", fun = plotMixMdlComps,
arg = list(clusterDf[i, "mu"],
clusterDf[i, "sigma"],
clusterDf[i, "lambda"]),
lwd = 1.5, colour = cols[i])
}
p
gg_color_hue <- function(n) {
hues = seq(15, 375, length=n+1)
hcl(h=hues, l=65, c=100)[1:n]
}
plotMixMdlComps <- function(x, mu, sigma, lam) {
lam * dnorm(x, mu, sigma )
}
clusterDf <- data.frame(cluster = c(6,5,4,8,0,7,3),
mu = c(0.73908779, 0.43233777, 0.28041006, 0.35627709,
0.09330585, 0.18250758, 0.56998734),
sigma = c(0.06472281, 0.03218096, 0.02779751,
0.02208605, 0.02716692, 0.01890661,
0.02995616),
lambda = c(0.042749908, 0.254485536, 0.205602343,
0.404705236, 0.061058220, 0.024166972,
0.007231783))
inDf <- data.frame(x = c(0,1))
p <- ggplot(inDf, aes(x)) +
xlim(0,1) +
ylim(0,10)
for (i in 1:nrow(clusterDf)) {
p <- p + stat_function(geom = "line", fun = plotMixMdlComps,
arg = list(clusterDf[i, "mu"],
clusterDf[i, "sigma"],
clusterDf[i, "lambda"]),
lwd = 1.5)
}
p
rm(list=ls())
dev.off()
gg_color_hue <- function(n) {
hues = seq(15, 375, length=n+1)
hcl(h=hues, l=65, c=100)[1:n]
}
plotMixMdlComps <- function(x, mu, sigma, lam) {
lam * dnorm(x, mu, sigma )
}
clusterDf <- data.frame(cluster = c(6,5,4,8,0,7,3),
mu = c(0.73908779, 0.43233777, 0.28041006, 0.35627709,
0.09330585, 0.18250758, 0.56998734),
sigma = c(0.06472281, 0.03218096, 0.02779751,
0.02208605, 0.02716692, 0.01890661,
0.02995616),
lam = c(0.042749908, 0.254485536, 0.205602343,
0.404705236, 0.061058220, 0.024166972,
0.007231783))
inDf <- data.frame(x = c(0,1))
p <- ggplot(inDf, aes(x)) +
xlim(0,1) +
ylim(0,10)
for (i in 1:nrow(clusterDf)) {
p <- p + stat_function(geom = "line", fun = plotMixMdlComps,
arg = list(clusterDf[i, "mu"],
clusterDf[i, "sigma"],
clusterDf[i, "lambda"]),
lwd = 1.5)
}
p
rm(list=ls())
dev.off()
gg_color_hue <- function(n) {
hues = seq(15, 375, length=n+1)
hcl(h=hues, l=65, c=100)[1:n]
}
plotMixMdlComps <- function(x, mu, sigma, lam) {
lam * dnorm(x, mu, sigma )
}
clusterDf <- data.frame(cluster = c(6,5,4,8,0,7,3),
mu = c(0.73908779, 0.43233777, 0.28041006, 0.35627709,
0.09330585, 0.18250758, 0.56998734),
sigma = c(0.06472281, 0.03218096, 0.02779751,
0.02208605, 0.02716692, 0.01890661,
0.02995616),
lam = c(0.042749908, 0.254485536, 0.205602343,
0.404705236, 0.061058220, 0.024166972,
0.007231783))
inDf <- data.frame(x = c(0,1))
p <- ggplot(inDf, aes(x)) +
xlim(0,1) +
ylim(0,10)
for (i in 1:nrow(clusterDf)) {
p <- p + stat_function(geom = "line", fun = plotMixMdlComps,
arg = list(clusterDf[i, "mu"],
clusterDf[i, "sigma"],
clusterDf[i, "lam"]),
lwd = 1.5)
}
p
rm(list=ls())
dev.off()
gg_color_hue <- function(n) {
hues = seq(15, 375, length=n+1)
hcl(h=hues, l=65, c=100)[1:n]
}
plotMixMdlComps <- function(x, mu, sigma, lam) {
lam * dnorm(x, mu, sigma )
}
clusterDf <- data.frame(cluster = c(6,5,4,8,0,7,3),
mu = c(0.73908779, 0.43233777, 0.28041006, 0.35627709,
0.09330585, 0.18250758, 0.56998734),
sigma = c(0.06472281, 0.03218096, 0.02779751,
0.02208605, 0.02716692, 0.01890661,
0.02995616),
lam = c(0.042749908, 0.254485536, 0.205602343,
0.404705236, 0.061058220, 0.024166972,
0.007231783))
inDf <- data.frame(x = c(0,1))
p <- ggplot(inDf, aes(x)) +
xlim(0,1) +
ylim(0,10)
for (i in 1:nrow(clusterDf)) {
p <- p + stat_function(geom = "line", fun = plotMixMdlComps,
args = list(clusterDf[i, "mu"],
clusterDf[i, "sigma"],
clusterDf[i, "lam"]),
lwd = 1.5)
}
p
clusterDf
nrow(clusterDF)
nrow("clusterDF")
rm(list=ls())
dev.off()
gg_color_hue <- function(n) {
hues = seq(15, 375, length=n+1)
hcl(h=hues, l=65, c=100)[1:n]
}
plotMixMdlComps <- function(x, mu, sigma, lam) {
lam * dnorm(x, mu, sigma )
}
clusterDf <- data.frame(cluster = c(6,5,4,8,0,7,3),
mu = c(0.73908779, 0.43233777, 0.28041006, 0.35627709,
0.09330585, 0.18250758, 0.56998734),
sigma = c(0.06472281, 0.03218096, 0.02779751,
0.02208605, 0.02716692, 0.01890661,
0.02995616),
lam = c(0.042749908, 0.254485536, 0.205602343,
0.404705236, 0.061058220, 0.024166972,
0.007231783))
inDf <- data.frame(x = c(0,1))
p <- ggplot(inDf, aes(x)) +
xlim(0,1) +
ylim(0,10)
for (i in 1:nrow(clusterDf)) {
p <- p + stat_function(geom = "line", fun = plotMixMdlComps,
lwd = 1.5)
}
p
help(geom_smooth)
help(sd)
runApp()
help(scales)
runApp()
runApp()
runApp()
runApp()
unique(dat[input$zcol])
runApp()
runApp()
runApp()
runApp()
runApp()
B
B[n]
B[1]
B
logistic[n]
runApp()
getPar(prueba)$params$bottom
runApp()
getPar(prueba)$params$bottom
getPar(prueba)
shiny::runApp()
runApp()
df2()
names(df2())
unique(df2())
as.numeric(unlist(dat[input$xcol]))
runApp()
runApp()
runApp()
typeof(df2())
str(df2())
length(df2())
length(unique(df2()))
nrow(df2())
runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
help(tabItem)
runApp('pruebas.R')
runApp('pruebas.R')
runApp('pruebas.R')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp('pruebas.R')
runApp()
runApp('pruebas.R')
runApp('pruebas.R')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
as.numeric(unlist(dat[input$xcol]))
prueba
df2()
shiny::runApp()
runApp()
runApp()
help("scale_x_log10")
runApp()
help(quantile)
help(which.min)
help(abs)
pki.app.s4s.get.starting.parameters <- function(input.data, fixed = list()) {
# Set starting parameters
x <- input.data[, "x"]
y <- input.data[, "y"]
n <- nrow(input.data)
xy <- x * y
start <- list()
if (!"a" %in% names(fixed)) {
start["a"] = quantile(y, 1, na.rm = TRUE)[[1]]
}
if (!"b" %in% names(fixed)) {
start["b"] = quantile(y, 0, na.rm = TRUE)[[1]]
}
if (length(y) > 2) {
mid.y <- (max(y) + min(y)) / 2
start["c"] = input.data[which.min(abs(input.data$y - mid.y)), "x"]
} else {
start["c"] = mean(x, na.rm = TRUE)[[1]]
}
d = 0
if (!"d" %in% names(fixed)) {
d <- (n * (sum(xy) - sum(x) * sum(y))) / abs(n * (sum(x ^ 2) - sum(y ^ 2)))
}
if (is.na(d)) {
start["d"] <- 0
} else if (d < 1) {
start["d"] = floor(d)
} else {
start["d"] = ceiling(d)
}
return(start)
}
a
x
b
c
d
input.data<- read.csv(("C:/Users/Capitán Tomate/Desktop/PERKIN ELMER/Samples/multicell3.csv"), header =TRUE, check.names = FALSE)
pki.app.s4s.get.starting.parameters <- function(input.data, fixed = list()) {
# Set starting parameters
x <- input.data[, "x"]
y <- input.data[, "y"]
n <- nrow(input.data)
xy <- x * y
start <- list()
if (!"a" %in% names(fixed)) {
start["a"] = quantile(y, 1, na.rm = TRUE)[[1]]
}
if (!"b" %in% names(fixed)) {
start["b"] = quantile(y, 0, na.rm = TRUE)[[1]]
}
if (length(y) > 2) {
mid.y <- (max(y) + min(y)) / 2
start["c"] = input.data[which.min(abs(input.data$y - mid.y)), "x"]
} else {
start["c"] = mean(x, na.rm = TRUE)[[1]]
}
d = 0
if (!"d" %in% names(fixed)) {
d <- (n * (sum(xy) - sum(x) * sum(y))) / abs(n * (sum(x ^ 2) - sum(y ^ 2)))
}
if (is.na(d)) {
start["d"] <- 0
} else if (d < 1) {
start["d"] = floor(d)
} else {
start["d"] = ceiling(d)
}
return(start)
}
x
pki.app.s4s.get.starting.parameters
pki.app.s4s.get.starting.parameters()
rm(list =ls())
dev.off()
input.data<- read.csv(("C:/Users/Capitán Tomate/Desktop/PERKIN ELMER/Samples/multicell3.csv"), header =TRUE, check.names = FALSE)
pki.app.s4s.get.starting.parameters <- function(input.data, fixed = list()) {
# Set starting parameters
x <- input.data[, "x"]
y <- input.data[, "y"]
n <- nrow(input.data)
xy <- x * y
start <- list()
if (!"a" %in% names(fixed)) {
start["a"] = quantile(y, 1, na.rm = TRUE)[[1]]
}
if (!"b" %in% names(fixed)) {
start["b"] = quantile(y, 0, na.rm = TRUE)[[1]]
}
if (length(y) > 2) {
mid.y <- (max(y) + min(y)) / 2
start["c"] = input.data[which.min(abs(input.data$y - mid.y)), "x"]
} else {
start["c"] = mean(x, na.rm = TRUE)[[1]]
}
d = 0
if (!"d" %in% names(fixed)) {
d <- (n * (sum(xy) - sum(x) * sum(y))) / abs(n * (sum(x ^ 2) - sum(y ^ 2)))
}
if (is.na(d)) {
start["d"] <- 0
} else if (d < 1) {
start["d"] = floor(d)
} else {
start["d"] = ceiling(d)
}
return(start)
}
View(pki.app.s4s.get.starting.parameters)
source('~/GitHub/Atlassian/TIBCO Plot/pki.app.s4s.get.starting.parameters.r', encoding = 'UTF-8')
source('~/GitHub/Atlassian/TIBCO Plot/pki.app.s4s.get.starting.parameters.r', encoding = 'UTF-8')
source('~/GitHub/Atlassian/TIBCO Plot/pki.app.s4s.get.starting.parameters.r', encoding = 'UTF-8')
source('~/GitHub/Atlassian/TIBCO Plot/pki.app.s4s.get.starting.parameters.r', encoding = 'UTF-8')
rm(list =ls())
dev.off()
input.data<- read.csv(("C:/Users/Capitán Tomate/Desktop/PERKIN ELMER/Samples/multicell3.csv"), header =TRUE, check.names = FALSE)
pki.app.s4s.get.starting.parameters <- function(input.data, fixed = list()) {
# Set starting parameters
x <- input.data[, "x"]
y <- input.data[, "y"]
n <- nrow(input.data)
xy <- x * y
start <- list()
if (!"a" %in% names(fixed)) {
start["a"] = quantile(y, 1, na.rm = TRUE)[[1]]
}
if (!"b" %in% names(fixed)) {
start["b"] = quantile(y, 0, na.rm = TRUE)[[1]]
}
if (length(y) > 2) {
mid.y <- (max(y) + min(y)) / 2
start["c"] = input.data[which.min(abs(input.data$y - mid.y)), "x"]
} else {
start["c"] = mean(x, na.rm = TRUE)[[1]]
}
d = 0
if (!"d" %in% names(fixed)) {
d <- (n * (sum(xy) - sum(x) * sum(y))) / abs(n * (sum(x ^ 2) - sum(y ^ 2)))
}
if (is.na(d)) {
start["d"] <- 0
} else if (d < 1) {
start["d"] = floor(d)
} else {
start["d"] = ceiling(d)
}
return(start)
}
print(start)
rm(list =ls())
dev.off()
input.data<- read.csv(("C:/Users/Capitán Tomate/Desktop/PERKIN ELMER/Samples/multicell3.csv"), header =TRUE, check.names = FALSE)
pki.app.s4s.get.starting.parameters <- function(input.data, fixed = list()) {
# Set starting parameters
x <- input.data[, "x"]
y <- input.data[, "y"]
n <- nrow(input.data)
xy <- x * y
start <- list()
if (!"a" %in% names(fixed)) {
start["a"] = quantile(y, 1, na.rm = TRUE)[[1]]
}
if (!"b" %in% names(fixed)) {
start["b"] = quantile(y, 0, na.rm = TRUE)[[1]]
}
if (length(y) > 2) {
mid.y <- (max(y) + min(y)) / 2
start["c"] = input.data[which.min(abs(input.data$y - mid.y)), "x"]
} else {
start["c"] = mean(x, na.rm = TRUE)[[1]]
}
d = 0
if (!"d" %in% names(fixed)) {
d <- (n * (sum(xy) - sum(x) * sum(y))) / abs(n * (sum(x ^ 2) - sum(y ^ 2)))
}
if (is.na(d)) {
start["d"] <- 0
} else if (d < 1) {
start["d"] = floor(d)
} else {
start["d"] = ceiling(d)
}
return(start)
}
print(start())
runApp()
runApp()
runApp()
data
data()
data()
x
data$x
df$x
a
b
dat
runApp()
help(floor)
help(geom_smooth)
runApp()
runApp()
runApp()
runApp()
runApp()
